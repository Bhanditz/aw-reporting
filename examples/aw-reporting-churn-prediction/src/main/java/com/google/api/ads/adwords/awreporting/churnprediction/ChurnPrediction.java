package com.google.api.ads.adwords.awreporting.churnprediction;

import com.google.api.ads.adwords.awreporting.churnprediction.db.DatabaseManager;
import com.google.api.ads.adwords.awreporting.churnprediction.entities.AccountSignals;
import com.google.api.ads.adwords.awreporting.churnprediction.entities.AccountStatus;
import com.google.api.ads.adwords.awreporting.churnprediction.signals.SignalProcessor;
import com.google.api.ads.adwords.awreporting.model.util.DateUtil;
import com.google.api.client.util.Lists;

import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.FileAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.joda.time.DateTime;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.io.IOException;
import java.util.List;

/**
 * TODO: Insert description here. (generated by gustavomoreira)
 */
public class ChurnPrediction {
  private static final Logger LOGGER = Logger.getLogger(ChurnPrediction.class);

  /**
   * The Spring application context used to get all the beans.
   */
  private static ApplicationContext appCtx;


  public static void main(String[] args) {
    Options options = createCommandLineOptions();

    boolean errors = false;
    String propertiesPath = null;

    try {
      CommandLineParser parser = new BasicParser();
      CommandLine cmdLine = parser.parse(options, args);

      // Print full help and quit
      if (cmdLine.hasOption("help")) {
        printHelpMessage(options);
        System.exit(0);
      }

      setLogLevel(cmdLine);

      //      if (cmdLine.hasOption("file")) {
      //        propertiesPath = cmdLine.getOptionValue("file");
      //      } else {
      //        LOGGER.error("Missing required option: 'file'");
      //        System.exit(0);
      //      }
      //      LOGGER.info("Using properties file: " + propertiesPath);


      initApplicationContextAndProperties();

      LOGGER.debug("Creating SignalProcess bean...");
      SignalProcessor processor = createSignalProcessor();
      LOGGER.debug("... success.");

      LOGGER.debug("Creating DatabaseReader bean...");
      DatabaseManager databaseManager = createDatabaseReader();
      LOGGER.debug("... success.");

      if (cmdLine.hasOption("startDate") && cmdLine.hasOption("endDate")) {
        // Generate Reports

        String dateStart = cmdLine.getOptionValue("startDate");
        String dateEnd = cmdLine.getOptionValue("endDate");

        DateTime startDate = DateUtil.parseDateTime(dateStart);
        DateTime endDate = DateUtil.parseDateTime(dateEnd);

        // TODO create account signals
        List<AccountStatus> accountsStatus = databaseManager.listAccountsStatus();
        for (AccountStatus accountStatus : accountsStatus) {
          // TODO LOGGERs
          AccountSignals signals =
              processor.createSignalsForAccount(accountStatus.getAccountId(), startDate, endDate);

          databaseManager.saveAccountSignals(signals);
        }


        // TODO if training or predicting



      } else {
        errors = true;
        LOGGER.error("Configuration incomplete. Missing options for command line.");
      }

    } catch (IOException e) {
      errors = true;

      if (e.getMessage().contains("Insufficient Permission")) {
        LOGGER.error("Insufficient Permission error accessing the API" + e.getMessage());
      } else {
        LOGGER.error("File not found: " + e.getMessage());
      }

    } catch (ParseException e) {
      errors = true;
      System.err.println(
          "Error parsing the values for the command line options: " + e.getMessage());
    } catch (Exception e) {
      errors = true;
      LOGGER.error("Unexpected error accessing the API: " + e.getMessage());
      e.printStackTrace();
    }

    if (errors) {
      System.exit(1);
    } else {
      System.exit(0);
    }
  }

  /**
   * @return
   */
  private static DatabaseManager createDatabaseReader() {
    return appCtx.getBean(DatabaseManager.class);
  }

  /**
   * @return
   */
  private static SignalProcessor createSignalProcessor() {
    return appCtx.getBean(SignalProcessor.class);
  }

  private static void printHelpMessage(Options options) {
    // automatically generate the help statement
    System.out.println();
    HelpFormatter formatter = new HelpFormatter();
    formatter.setWidth(120);
    formatter.printHelp(
        " java -Xmx1G -jar aw-reporting.jar -startDate YYYYMMDD -endDate YYYYMMDD "
        + "-file <file>\n java -Xmx1G -jar aw-reporting.jar "
        + "-startDate YYYYMMDD -endDate YYYYMMDD -file <file>",
        "\nArguments:", options, "");
    System.out.println();
  }

  /**
   * Creates the command line options.
   *
   * @return the {@link Options}.
   */
  private static Options createCommandLineOptions() {
    Options options = new Options();
    Option help = new Option("help", "print this message");
    options.addOption(help);

    OptionBuilder.withArgName("file");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription("aw-report-sample.properties file.");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("file"));

    OptionBuilder.withArgName("YYYYMMDD");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription("Start date for CUSTOM_DATE Reports (YYYYMMDD)");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("startDate"));

    OptionBuilder.withArgName("YYYMMDD");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription("End date for CUSTOM_DATE Reports (YYYYMMDD)");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("endDate"));

    OptionBuilder.withArgName("DateRangeType");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription("ReportDefinitionDateRangeType");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("dateRange"));

    OptionBuilder.withArgName("accountIdsFile");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription(
        "Consider ONLY the account IDs specified on the file to run the report");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("accountIdsFile"));

    OptionBuilder.withArgName("verbose");
    OptionBuilder.hasArg(false);
    OptionBuilder.withDescription("The application will print all the tracing on the console");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("verbose"));

    OptionBuilder.withArgName("debug");
    OptionBuilder.hasArg(false);
    OptionBuilder.withDescription("Will display all the debug information. "
        + "If the option 'verbose' is activated, "
        + "all the information will be displayed on the console as well");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("debug"));

    OptionBuilder.withArgName("onFileReport");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription("This is an experimental argument, where you can specify "
        + "the report type, and the processor will read the data directly from the CSV file "
        + "passed on the 'csvReportFile' argument. It's mandatory to pass the 'csvReportFile' "
        + "argument if you pass this argument.");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("onFileReport"));

    OptionBuilder.withArgName("csvReportFile");
    OptionBuilder.hasArg(true);
    OptionBuilder.withDescription("This is the path to the CSV report file that will be used to "
        + "import data directly into AwReporting.");
    OptionBuilder.isRequired(false);
    options.addOption(OptionBuilder.create("csvReportFile"));

    return options;
  }

  /**
   * Sets the Log level based on the command line arguments
   *
   * @param commandLine the command line
   */
  private static void setLogLevel(CommandLine commandLine) {
    Level logLevel = Level.INFO;

    if (commandLine.hasOption("debug")) {
      logLevel = Level.DEBUG;
    }

    ConsoleAppender console = new ConsoleAppender(); // create appender
    String pattern = "%d [%p|%c|%C{1}] %m%n";
    console.setLayout(new PatternLayout(pattern));
    console.activateOptions();
    if (commandLine.hasOption("verbose")) {
      console.setThreshold(logLevel);
    } else {
      console.setThreshold(Level.ERROR);
    }
    Logger.getLogger("com.google.api.ads.adwords.awreporting.churnprediction").addAppender(console);

    FileAppender fa = new FileAppender();
    fa.setName("FileLogger");
    fa.setFile("aw-reporting-churn-prediction.log");
    fa.setLayout(new PatternLayout("%d %-5p [%c{1}] %m%n"));
    fa.setThreshold(logLevel);
    fa.setAppend(true);
    fa.activateOptions();
    Logger.getLogger("com.google.api.ads.adwords.awreporting.churnprediction").addAppender(fa);
  }


  private static void initApplicationContextAndProperties() throws IOException {
    LOGGER.trace("Innitializing Spring application context.");

    // Selecting the XMLs to choose the Spring Beans to load.
    List<String> listOfClassPathXml = Lists.newArrayList();

    LOGGER.info("Using SQL DB configuration properties.");
    LOGGER.warn("Updating database schema, this could take a few minutes ...");
    listOfClassPathXml.add("classpath:aw-report-churn-prediction-beans.xml");
    LOGGER.warn("Done.");

    appCtx = new ClassPathXmlApplicationContext(
        listOfClassPathXml.toArray(new String[listOfClassPathXml.size()]));
  }
}
