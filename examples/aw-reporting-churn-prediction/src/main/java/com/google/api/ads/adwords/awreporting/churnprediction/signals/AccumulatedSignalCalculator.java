package com.google.api.ads.adwords.awreporting.churnprediction.signals;

import com.google.api.ads.adwords.awreporting.churnprediction.annotations.AccumulatedSignal;
import com.google.api.ads.adwords.awreporting.model.entities.ReportAccount;
import com.google.api.ads.adwords.awreporting.model.entities.ReportBase;
import com.google.api.ads.adwords.awreporting.model.util.DateUtil;

import org.apache.commons.beanutils.PropertyUtils;
import org.joda.time.DateTime;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.util.List;

/**
 * TODO: Insert description here. (generated by gustavomoreira)
 */
public class AccumulatedSignalCalculator implements SignalCalculator {
  private String propertyName;

  private int days;

  private int months;

  public AccumulatedSignalCalculator(AccumulatedSignal accumulatedSignal) {
    this.propertyName = accumulatedSignal.property();
    this.days = accumulatedSignal.days();
    this.months = accumulatedSignal.months();
  }

  @Override
  public Object calculateValueForAccount(List<ReportAccount> dataRows, Field field)
      throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
    Number accumulatedValue = null;
    DateTime firstDate = null;

    for (ReportBase report : dataRows) {
      DateTime dateTime = DateUtil.parseDateTime(report.getDay());
      if (firstDate == null) {
        firstDate = dateTime;
      }

      if (this.days > 0 && dateTime.plusDays(this.days - 1).isBefore(firstDate)) {
        break;
      } else if (this.months > 0 && dateTime.plusMonths(this.months - 1).isBefore(firstDate)) {
        break;
      }

      Object propertyValue = PropertyUtils.getProperty(report, this.propertyName);
      Class propertyType = PropertyUtils.getPropertyType(report, this.propertyName);
      if (String.class.isAssignableFrom(propertyType)) {
        accumulatedValue =
            this.addAsBigDecimal(accumulatedValue, new BigDecimal((String) propertyValue));

      } else if (Long.class.isAssignableFrom(propertyType)) {
        accumulatedValue = this.addAsLong(accumulatedValue, (Long) propertyValue);
      }
    }
    return this.returnCorrectNumberType(accumulatedValue, field);
  }

  /**
   * @param accumulatedValue
   * @param field
   * @return
   */
  private Object returnCorrectNumberType(Number accumulatedValue, Field field) {
    if (field.getType().equals(Double.TYPE)) {
      if (accumulatedValue == null) {
        return SignalProcessor.INVALID_DOUBLE_SIGNAL;
      }
      return accumulatedValue.doubleValue();
    } else if (field.getType().equals(Long.TYPE)) {
      if (accumulatedValue == null) {
        return SignalProcessor.INVALID_LONG_SIGNAL;
      }
      return accumulatedValue.longValue();
    } else if (field.getType().equals(Integer.TYPE)) {
      if (accumulatedValue == null) {
        return SignalProcessor.INVALID_INTEGER_SIGNAL;
      }
      return accumulatedValue.intValue();
    }
    return accumulatedValue;
  }

  /**
   * @param accumulatedValue
   * @param propertyValue
   * @return
   */
  private Number addAsLong(Number accumulatedValue, Long propertyValue) {
    if (accumulatedValue == null) {
      return propertyValue;
    } else if (propertyValue == null) {
      return accumulatedValue;
    }
    return accumulatedValue.longValue() + propertyValue;
  }

  /**
   * @param accumulatedValue
   * @param propertyValue
   * @return
   */
  private Number addAsBigDecimal(Number accumulatedValue, BigDecimal propertyValue) {
    if (accumulatedValue == null) {
      return propertyValue;
    } else if (propertyValue == null) {
      return accumulatedValue;
    }
    return propertyValue.add((BigDecimal) accumulatedValue);
  }
}
